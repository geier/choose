#!/usr/bin/env python
# coding: utf-8
# Copyright (c) 2012-2014 Christian Geier and contributors
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"""simple chooser program

reads lines from stdin, lets user choose one line in an urwid (ncurses like)
interface, prints it to stdout and exits. Input will be aligned to tabs '\t'.
It does read and wirte directly into the currently active tty, thus working
like this: `get_data | choose`
"""
from __future__ import print_function

import urwid
import sys
import os


def get_terminal_size():
    """ taken from
    http://stackoverflow.com/questions/566746/566752#566752
    by user Johannes Weiss http://stackoverflow.com/users/55925/johannes-weiss
    """
    env = os.environ

    def ioctl_GWINSZ(filedesc):
        try:
            import fcntl
            import termios
            import struct
            con_props = struct.unpack('hh', fcntl.ioctl(filedesc,
                                                        termios.TIOCGWINSZ,
                                                        '1234'))
        except IOError:
            return None
        return con_props
    con_props = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not con_props:
        try:
            filedesc = os.open(os.ctermid(), os.O_RDONLY)
            con_props = ioctl_GWINSZ(filedesc)
            os.close(filedesc)
        except IOError:
            pass
    if not con_props:
        try:
            con_props = (env['LINES'], env['COLUMNS'])
        except:
            con_props = (25, 80)
    return int(con_props[1]), int(con_props[0])


def get_terminal_size_wrapper():
    """wrapper function, if we are on py3.3+ it will use the build in function,
    otherwise our own"""
    try:
        # python3.3+
        import shutil
        termsize = shutil.get_terminal_size()
        return termsize.columns, termsize.lines
    except AttributeError:
        return get_terminal_size()


def select_entry(names, header_text=''):
    """interactive href selector (urwid based)

    returns: href
    return type: string
    """
    class SelText(urwid.Text):
        """Selectable Text, saving index"""
        def __init__(self, text):
            urwid.Text.__init__(self, text)

        @classmethod
        def selectable(cls):
            """needs to be implemented"""
            return True

        @classmethod
        def keypress(cls, _, key):
            """needs to be implemented"""
            return key

    class Selected(Exception):
        """
        used for signalling that an item was chosen in urwid
        """
        pass

    if len(names) is 1:
        return names[0]
    if names == list():
        return None
    name_list = list()
    for one in names:
        name_list.append(SelText(one))
    palette = [('header', 'white', 'black'),
               ('reveal focus', 'black', 'dark cyan', 'standout'), ]
    content = urwid.SimpleListWalker([
        urwid.AttrMap(w, None, 'reveal focus') for w in name_list])

    listbox = urwid.ListBox(content)
    header = urwid.Text(header_text, wrap='clip')
    head = urwid.AttrMap(header, 'header')
    top = urwid.Frame(listbox, head)

    def keystroke(input):
        """used for urwid test
        to be removed
        """
        if input == 'q':
            raise urwid.ExitMainLoop()
        if input is 'enter':
            listbox.get_focus()[0].original_widget
            raise Selected()

    loop = urwid.MainLoop(top, palette,
                          unhandled_input=keystroke)
    try:
        loop.run()
    except Selected:
        return listbox.get_focus()[1]


def do_it(choice):
    width, _ = get_terminal_size_wrapper()

    def get_lengths(choice):
        """return max lengths of strings in 'columns' """
        # list() for python3 compat.
        return list(map(max, list(zip(*[map(len, one) for one in choice]))))

    # main work is done here
    choice = choice.split('\n')[:-1]  # last line is always empty
    orig_choice = choice
    choice = [one.split('\t') for one in choice]

    #make sure all have elements have the same number of elements
    number_elements = max([len(one) for one in choice])
    for ind, _ in enumerate(choice):
        while len(choice[ind]) < number_elements:
            choice[ind].append('')

    lengths = get_lengths(choice)
    number_columns = len(lengths)
    number_splits = number_columns - 1

    while sum(lengths) + number_splits > width:
        missing = width - sum(lengths) - number_splits
        number_offenders = 0
        for length in lengths:
            if length > width / number_columns + number_splits:
                number_offenders = number_offenders + 1
        for ind, length in enumerate(lengths):
            if length > width / number_columns + number_splits:
                lengths[ind] = lengths[ind] + missing / number_offenders
                break

    # set length of column[i] to length[i], either clip or extent
    choice = [[s[:length].ljust(length + 1) for s, length in list(zip(wahl, lengths))] for wahl in choice]

    choice = [''.join(elemente) for elemente in choice]
    index = select_entry(choice,
                         header_text=u'Navigate by pressing ↑ and ↓, select by pressing Enter')

    return orig_choice[index]


if __name__ == "__main__":
    choice = sys.stdin.read()

    # save old stdout and in
    old_out = sys.__stdout__
    old_in = sys.__stdin__
    old_err = sys.__stderr__
    sys.__stdout__ = sys.stdout = open('/dev/tty', 'w')
    sys.__stdin__ = sys.stdin = open('/dev/tty')
    os.dup2(sys.stdin.fileno(), 0)

    choice = do_it(choice)
    print(choice)

    #restore old stdout
    sys.stdout.flush()
    sys.stderr.flush()
    sys.stdin.close()
    sys.stdout.close()
    sys.stderr.close()
    sys.__stdout__ = sys.stdout = old_out
    sys.__stdin__ = sys.stdin = old_in
    sys.__stderr__ = sys.stderr = old_err
