#!/usr/bin/env python
# coding: utf-8
"""simple chooser program

reads lines from stdin, lets user choose one line in an urwid (ncurses like)
interface, prints it to stdout and exits. Input will be aligned to tabs '\t'.
It does read and wirte directly into the currently active tty, thus working
like this: `get_data | choose`
"""

import urwid
import sys
import os


def get_terminal_size():
    """ taken from
    http://stackoverflow.com/questions/566746/566752#566752
    by user Johannes Weiss http://stackoverflow.com/users/55925/johannes-weiss
    """
    env = os.environ

    def ioctl_GWINSZ(filedesc):
        try:
            import fcntl
            import termios
            import struct
            con_props = struct.unpack('hh', fcntl.ioctl(filedesc,
                                                        termios.TIOCGWINSZ,
                                                        '1234'))
        except IOError:
            return None
        return con_props
    con_props = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not con_props:
        try:
            filedesc = os.open(os.ctermid(), os.O_RDONLY)
            con_props = ioctl_GWINSZ(filedesc)
            os.close(filedesc)
        except IOError:
            pass
    if not con_props:
        try:
            con_props = (env['LINES'], env['COLUMNS'])
        except:
            con_props = (25, 80)
    return int(con_props[1]), int(con_props[0])


def get_terminal_size_wrapper():
    """wrapper function, if we are on py3.3+ it will use the build in function,
    otherwise our own"""
    try:
        # python3.3+
        import shutil
        termsize = shutil.get_terminal_size()
        return termsize.columns, termsize.lines
    except AttributeError:
        return get_terminal_size()


def select_entry(names, header_text=''):
    """interactive href selector (urwid based)

    returns: href
    return type: string
    """
    class SelText(urwid.Text):
        """Selectable Text, saving index"""
        def __init__(self, text):
            urwid.Text.__init__(self, text)
            self.orig_text = text
            self.selected = False

        @classmethod
        def selectable(cls):
            """needs to be implemented"""
            return True

        def keypress(self, _, key):
            """needs to be implemented"""
            if key == 'enter':
                raise Selected(self.orig_text)
            return key

    class Selected(Exception):
        """
        used for signalling that an item was chosen in urwid
        """
        def __init__(self, exit_token=None):
            self.exit_token = exit_token

    class MyFrame(urwid.Frame):
        def __init__(self, filterfun=None, *args, **kwargs):
            self._filter = filterfun
            super(MyFrame, self).__init__(*args, **kwargs)

        def keypress(self, size, key):
            if key not in ['enter', 'esc', 'down', 'up']:
                out = self._footer.keypress([1], key=key)
                self._filter(self.footer.text)
                return out
            else:
                return super(MyFrame, self).keypress(size, key)

    class MySimpleListWalker(urwid.SimpleListWalker):
        original_content = None

        def filter(self, string):
            if self.original_content is None:
                self.original_content = self.contents
            for num, line in enumerate(self.contents):
                text = line.original_widget.text
                if string not in text.decode('utf-8'):
                    self.contents.pop(num)

    if len(names) is 1:
        return names[0]
    if names == list():
        return None
    name_list = list()

    for one in names:
        name_list.append(SelText(one))
    palette = [('header', 'white', 'black'),
               ('reveal focus', 'black', 'dark cyan', 'standout'), ]
    content = MySimpleListWalker([
        urwid.AttrMap(w, None, 'reveal focus') for w in name_list])

    listbox = urwid.ListBox(content)
    header = urwid.Text(header_text, wrap='clip')
    head = urwid.AttrMap(header, 'header')
    foot = urwid.Edit()
    top = MyFrame(content.filter, listbox, head, footer=foot)

    def keystroke(input):
        """used for urwid test
        to be removed
        """
        if input in ['q', 'esc']:
            raise urwid.ExitMainLoop()

    loop = urwid.MainLoop(top, palette, unhandled_input=keystroke)
    try:
        loop.run()
    except Selected as error:
        return error.exit_token


def do_it(auswahl):
    width, _ = get_terminal_size_wrapper()

    def get_lengths(auswahl):
        """return max lengths of strings in 'columns' """
        # list() for python3 compat.
        return list(map(max, list(zip(*[map(len, one) for one in auswahl]))))

    # main work is done here
    auswahl = auswahl.split('\n')[:-1]  # last line is always empty
    auswahl = [one.split('\t') for one in auswahl]

    #make sure all have elements have the same number of elements
    number_elements = max([len(one) for one in auswahl])
    for ind, _ in enumerate(auswahl):
        while len(auswahl[ind]) < number_elements:
            auswahl[ind].append('')

    laengen = get_lengths(auswahl)
    number_columns = len(laengen)
    number_splits = number_columns - 1

    while sum(laengen) + number_splits > width:
        missing = width - sum(laengen) - number_splits
        number_offenders = 0
        for lang in laengen:
            if lang > width / number_columns + number_splits:
                number_offenders = number_offenders + 1
        for ind, lang in enumerate(laengen):
            if lang > width / number_columns + number_splits:
                laengen[ind] = laengen[ind] + missing / number_offenders
                break

    # set length of column[i] to length[i], either clip or extent
    auswahl = [[s[:lange].ljust(lange + 1) for s, lange in list(zip(wahl, laengen))] for wahl in auswahl]

    auswahl = [''.join(elemente) for elemente in auswahl]
    out = select_entry(auswahl,
                       header_text=u'Navigate by pressing ↑ and ↓, select by pressing Enter')

    # print chosen string
    if out is not None:
        print(out)


if __name__ == "__main__":
    auswahl = sys.stdin.read()

    # save old stdout and in
    old_out = sys.__stdout__
    old_in = sys.__stdin__
    old_err = sys.__stderr__
    sys.__stdout__ = sys.stdout = open('/dev/tty', 'w')
    sys.__stdin__ = sys.stdin = open('/dev/tty')
    os.dup2(sys.stdin.fileno(), 0)

    do_it(auswahl)

    #restore old stdout
    sys.stdout.flush()
    sys.stderr.flush()
    sys.stdin.close()
    sys.stdout.close()
    sys.stderr.close()
    sys.__stdout__ = sys.stdout = old_out
    sys.__stdin__ = sys.stdin = old_in
    sys.__stderr__ = sys.stderr = old_err
